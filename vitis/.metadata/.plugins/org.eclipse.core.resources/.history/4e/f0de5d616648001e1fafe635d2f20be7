#include <stdio.h>
#include "xparameters.h"

#include "xspips.h"
#include "xgpiops.h"
#include "xscutimer.h"
#include "xscugic.h"

#include "xil_printf.h"
#include "sleep.h"

#define GPIOPS_ID XPAR_XGPIOPS_0_DEVICE_ID
#define SPIPS_ID XPAR_XSPIPS_0_DEVICE_ID
#define TIMER_DEVICE_ID XPAR_XSCUTIMER_0_DEVICE_ID
#define INTC_DEVICE_ID XPAR_SCUGIC_SINGLE_DEVICE_ID
#define TIMER_IRPT_INTR XPAR_SCUTIMER_INTR

#define TIMER_LOAD_VALUE 0x000000005

#define SENSOR_LED 7
#define SYS_RES_LED 8

#define SENSOR_KEY 12
#define SYS_RES_KEY 11

#define FRAME_REQ 54
#define SYS_RES_N 55
#define SENSOR_SWITCH 56

#define F 48.0
#define OFFSET 1000.0 * F / 40.0
#define SLOPE 12.0 / F

XScuGic Intc;
XScuTimer Timer;
XSpiPs Spi0;
XGpioPs gpiops_inst;

int frame_req = 0;
int sys_res_n = 1;
int sensor_switch = 0;

int spi0_init();
int gpio0_init();

int timer_init(XScuTimer *timer_ptr);
void timer_intr_handler(void *CallBackRef);
void timer_intr_init(XScuGic *intc_ptr, XScuTimer *timer_ptr);

void frame_req_pulse();
void spi_upload();
void start_up_sequence();
void reset_sequence();

u8 read_temperature_reg[4] = {0, 0, 0, 0};
u8 write_temperature_reg[4] = {0x7E, 0xFF, 0x7F, 0xFF};

u8 read_frame_num_reg[4] = {0, 0, 0, 0};
u8 write_frame_num_reg[4] = {0xC7, 0x01, 0xC6, 0x52};

int main()
{
    int Status;

    Status = gpio0_init();
    if (Status != XST_SUCCESS)
    {
        xil_printf("GPIO  Failed\r\n");
        return XST_FAILURE;
    }

    Status = spi0_init();
    if (Status != XST_SUCCESS)
    {
        xil_printf("SPI Selftest Example Failed\r\n");
        return XST_FAILURE;
    }

    Status = timer_init(&Timer); // 瀹氭椂鍣ㄥ垵濮嬪寲
    if (Status != XST_SUCCESS)
    {
        xil_printf("Timer Initial Failed\r\n");
        return XST_FAILURE;
    }

    timer_intr_init(&Intc, &Timer);

    start_up_sequence();

    while (1)
    {

        if (XGpioPs_ReadPin(&gpiops_inst, SYS_RES_KEY) == 0)
        {
            usleep(2000);
            if (XGpioPs_ReadPin(&gpiops_inst, SYS_RES_KEY) == 0)
            {
                XGpioPs_WritePin(&gpiops_inst, SYS_RES_LED, 1);
                reset_sequence();
                XGpioPs_WritePin(&gpiops_inst, SYS_RES_LED, 0);
            }
        }

        if (XGpioPs_ReadPin(&gpiops_inst, SENSOR_KEY) == 0)
        {
            usleep(2000);
            if (XGpioPs_ReadPin(&gpiops_inst, SENSOR_KEY) == 0)
            {
                sensor_switch = ~sensor_switch;
                XGpioPs_WritePin(&gpiops_inst, SENSOR_SWITCH, sensor_switch);
                XGpioPs_WritePin(&gpiops_inst, SENSOR_LED, sensor_switch);
            }
        }

        frame_req_pulse();

        XSpiPs_PolledTransfer(&Spi0, write_temperature_reg, read_temperature_reg, 4);

        double tem = (read_temperature_reg[3] * 256 + read_temperature_reg[1] - OFFSET) * SLOPE;

        printf("REG-127 = %#x\t", read_temperature_reg[3]);
        printf("REG-126 = %#x\n", read_temperature_reg[1]);
        printf("Temperature = %.2lf°C", tem);

        printf("\n\n");
        memset(read_temperature_reg, 0x00, 128);
        sleep(1);
    }

    return XST_SUCCESS;
}

int spi0_init()
{
    int Status;
    XSpiPs_Config *SpiConfig;

    /*
     * Initialize the SPI device.
     */
    SpiConfig = XSpiPs_LookupConfig(SPIPS_ID);
    if (NULL == SpiConfig)
    {
        return XST_FAILURE;
    }

    Status = XSpiPs_CfgInitialize(&Spi0, SpiConfig, SpiConfig->BaseAddress);
    if (Status != XST_SUCCESS)
    {
        return XST_FAILURE;
    }

    /*
     * Perform a self-test to check hardware build.
     */
    Status = XSpiPs_SelfTest(&Spi0);
    if (Status != XST_SUCCESS)
    {
        return XST_FAILURE;
    }
    xil_printf("%s self test succ\r\n", __func__);

    Status = XSpiPs_SetOptions(&Spi0, XSPIPS_MASTER_OPTION);
    if (Status != XST_SUCCESS)
    {
        xil_printf("%s SetOptions fail\n", __func__);
        return XST_FAILURE;
    }

    Status = XSpiPs_SetClkPrescaler(&Spi0, XSPIPS_CLK_PRESCALE_8);
    if (Status != XST_SUCCESS)
    {
        xil_printf("%s XSpiPs_SetClkPrescaler fail\n", __func__);
        return XST_FAILURE;
    }

    Status = XSpiPs_SetDelays(&Spi0, 0x00, 0x00, 0x00, 0x00);
    if (Status != XST_SUCCESS)
    {
        xil_printf("%s XSpiPs_SetDelays fail\n", __func__);
        return XST_FAILURE;
    }

    xil_printf("spi 0 config finish\n");
    return XST_SUCCESS;
}

int gpio0_init()
{
    int Status;

    XGpioPs_Config *gpiops_cfg_ptr;

    gpiops_cfg_ptr = XGpioPs_LookupConfig(GPIOPS_ID);
    if (NULL == gpiops_cfg_ptr)
    {
        return XST_FAILURE;
    }

    Status = XGpioPs_CfgInitialize(&gpiops_inst, gpiops_cfg_ptr,
                                   gpiops_cfg_ptr->BaseAddr);
    if (Status != XST_SUCCESS)
    {
        return XST_FAILURE;
    }

    XGpioPs_SetDirectionPin(&gpiops_inst, SENSOR_KEY, 0);
    XGpioPs_SetDirectionPin(&gpiops_inst, SYS_RES_KEY, 0);

    XGpioPs_SetDirectionPin(&gpiops_inst, SENSOR_LED, 1);
    XGpioPs_SetDirectionPin(&gpiops_inst, SYS_RES_LED, 1);
    XGpioPs_SetDirectionPin(&gpiops_inst, FRAME_REQ, 1);
    XGpioPs_SetDirectionPin(&gpiops_inst, SYS_RES_N, 1);
    XGpioPs_SetDirectionPin(&gpiops_inst, SENSOR_SWITCH, 1);

    XGpioPs_SetOutputEnablePin(&gpiops_inst, SENSOR_LED, 1);
    XGpioPs_SetOutputEnablePin(&gpiops_inst, SYS_RES_LED, 1);
    XGpioPs_SetOutputEnablePin(&gpiops_inst, FRAME_REQ, 1);
    XGpioPs_SetOutputEnablePin(&gpiops_inst, SYS_RES_N, 1);
    XGpioPs_SetOutputEnablePin(&gpiops_inst, SENSOR_SWITCH, 1);

    XGpioPs_WritePin(&gpiops_inst, SENSOR_LED, 0);
    XGpioPs_WritePin(&gpiops_inst, SYS_RES_LED, 0);
    XGpioPs_WritePin(&gpiops_inst, FRAME_REQ, 0);
    XGpioPs_WritePin(&gpiops_inst, SYS_RES_N, 0);
    XGpioPs_WritePin(&gpiops_inst, SENSOR_SWITCH, 0);

    return XST_SUCCESS;
}

// 瀹氭椂鍣ㄥ垵濮嬪寲绋嬪簭
int timer_init(XScuTimer *timer_ptr)
{
    int status;
    // 绉佹湁瀹氭椂鍣ㄥ垵濮嬪寲
    XScuTimer_Config *timer_cfg_ptr;
    timer_cfg_ptr = XScuTimer_LookupConfig(TIMER_DEVICE_ID);
    if (NULL == timer_cfg_ptr)
        return XST_FAILURE;
    status = XScuTimer_CfgInitialize(timer_ptr, timer_cfg_ptr, timer_cfg_ptr->BaseAddr);
    if (status != XST_SUCCESS)
        return XST_FAILURE;

    XScuTimer_LoadTimer(timer_ptr, TIMER_LOAD_VALUE); // 鍔犺浇璁℃暟鍛ㄦ湡
    XScuTimer_EnableAutoReload(timer_ptr);            // 璁剧疆鑷姩瑁呰浇妯″紡

    return XST_SUCCESS;
}

// 瀹氭椂鍣ㄤ腑鏂鐞嗙▼搴�
void timer_intr_handler(void *CallBackRef)
{

    XScuTimer *timer_ptr = (XScuTimer *)CallBackRef;
    if (frame_req == 1)
    {
        XGpioPs_WritePin(&gpiops_inst, FRAME_REQ, 0);
        frame_req = 0;
    }
    else if (sys_res_n == 0)
    {
        XGpioPs_WritePin(&gpiops_inst, SYS_RES_N, 1);
        sys_res_n = 1;
    }
    XScuTimer_ClearInterruptStatus(timer_ptr);
    XScuTimer_Stop(&Timer);
}

// 瀹氭椂鍣ㄤ腑鏂垵濮嬪寲
void timer_intr_init(XScuGic *intc_ptr, XScuTimer *timer_ptr)
{
    // 鍒濆鍖栦腑鏂帶鍒跺櫒
    XScuGic_Config *intc_cfg_ptr;
    intc_cfg_ptr = XScuGic_LookupConfig(INTC_DEVICE_ID);
    XScuGic_CfgInitialize(intc_ptr, intc_cfg_ptr, intc_cfg_ptr->CpuBaseAddress);
    // 璁剧疆骞舵墦寮�涓柇寮傚父澶勭悊鍔熻兘
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                 (Xil_ExceptionHandler)XScuGic_InterruptHandler, intc_ptr);
    Xil_ExceptionEnable();

    // 璁剧疆瀹氭椂鍣ㄤ腑鏂�
    XScuGic_Connect(intc_ptr, TIMER_IRPT_INTR,
                    (Xil_ExceptionHandler)timer_intr_handler, (void *)timer_ptr);

    XScuGic_Enable(intc_ptr, TIMER_IRPT_INTR); // 浣胯兘GIC涓殑瀹氭椂鍣ㄤ腑鏂�
    XScuTimer_EnableInterrupt(timer_ptr);      // 浣胯兘瀹氭椂鍣ㄤ腑鏂�
}

void frame_req_pulse()
{
    printf("\nframe_req_pulse\n\n");
    XGpioPs_WritePin(&gpiops_inst, FRAME_REQ, 1);
    frame_req = 1;
    XScuTimer_Start(&Timer);
    while (frame_req == 1)
        ;
}

void spi_upload()
{
    printf("\nspi_upload\n\n");
    XSpiPs_PolledTransfer(&Spi0, write_frame_num_reg, read_frame_num_reg, 4);
}

void start_up_sequence()
{
    printf("\nstart_up_sequence\n\n");
    XGpioPs_WritePin(&gpiops_inst, SYS_RES_N, 1);
    usleep(1);
    spi_upload();
    usleep(7000);
    frame_req_pulse();
}

void reset_sequence()
{
    printf("\nreset_sequence\n\n");
    XGpioPs_WritePin(&gpiops_inst, SYS_RES_N, 0);
    sys_res_n = 0;
    XScuTimer_Start(&Timer);
    while (sys_res_n == 0)
        ;
    usleep(1);
    spi_upload();
    usleep(7000);
    frame_req_pulse();
}
